---
description: 인증정책
---

# 5.4 Authentication

## Authentication

Istio는 두 가지 유형의 인증을 제공합니다.

* Peer Authentication : 연결하는 클라이언트를 확인하기 위해 서비스 간 인증에 사용됩니다. Istio는 서비스 코드 변경없이 활성화 할 수있는 전송 인증을위한 풀 스택 솔루션으로 상호 TLS를 제공합니다.
  * 각 서비스에 역할을 나타내는 강력한 ID를 제공하여 클러스터와 클라우드에서 상호 운용성을 지원합니다.
  * 서비스 간 통신을 보호합니다.
  * 키 및 인증서 생성, 배포 및 순환을 자동화하는 키 관리 시스템을 제공합니다.
* 요청 인증 : 요청에 첨부 된 자격 증명을 확인하기 위해 최종 사용자 인증에 사용됩니다. Istio는 JWT \(JSON Web Token\) 유효성 검사로 요청 수준 인증을 지원하고 사용자 지정 인증 공급자 또는 OpenID Connect 공급자를 사용하여 간소화 된 개발자 환경을 제공합니다. 예를 들면 다음과 같습니다.

  * ORY Hydra
  * Keycloak
  * AuthO
  * Firebase Auth
  * Google Auth

모든 경우에 Istio는 사용자 지정 Kubernetes API를 통해 Istio 구성 저장소에 인증 정책을 저장합니다. Istiod는 해당하는 경우 키와 함께 각 프록시에 대해 최신 상태로 유지합니다. 또한 Istio는 허용 모드의 인증을 지원하여 정책 변경이 적용되기 전에 보안 상태에 미치는 영향을 이해하는데 도움이 됩니다.



### Mutual TLS Authentication

Istio는 Envoy 프록시로 구현되는 클라이언트 및 서버 측 PEP를 통해 서비스 간 통신을 터널링합니다. 워크로드가 상호 TLS 인증을 사용하여 다른 워크로드에 요청을 보낼 때 요청은 다음과 같이 처리됩니다.

1. Istio는 클라이언트에서 클라이언트의 로컬 사이드카 Envoy로 아웃 바운드 트래픽을 다시 라우팅합니다.
2. 클라이언트 측 Envoy는 서버 측 Envoy와 상호 TLS 핸드 셰이크를 시작합니다. 핸드 셰이크 중에 클라이언트 측 Envoy는 보안 이름 지정 검사를 수행하여 서버 인증서에 제공된 서비스 계정이 대상 서비스를 실행할 권한이 있는지 확인합니다.
3. 클라이언트 측 Envoy와 서버 측 Envoy는 상호 TLS 연결을 설정하고 Istio는 클라이언트 측 Envoy에서 서버 측 Envoy로 트래픽을 전달합니다.
4. 승인 후 서버 측 Envoy는 로컬 TCP 연결을 통해 트래픽을 서버 서비스로 전달합니다.

### Permissive Mode

Istio 상호 TLS에는 허용 모드를 이용하여 서비스가 암호화 되지 않는 평문 트래픽과 암호화된 상호 TLS 트래픽을 동시에 수락 할 수 있습니다. 이 기능은 상호 TLS 온 보딩 경험을 크게 향상시킵니다.

non-Istio 서버와 통신하는 많은 non-Istio 클라이언트는 상호 TLS가 활성화 된 상태에서 해당 서버를 Istio로 마이그레이션하려는 운영자에게는 문제가 될 수 있습니다. 일반적으로 운영자는 모든 클라이언트에 대해 Istio 사이드카를 동시에 설치할 수 없거나 일부 클라이언트에서 이를 수행 할 수있는 권한도 없습니다. 서버에 Istio 사이드카를 설치 한 후에도 운영자는 기존 통신을 중단 없이 상호 TLS를 활성화 할 수 없습니다.

허용 모드가 활성화되면 서버는 평문  및 상호 TLS 트래픽을 모두 허용합니다. 이 모드는 온 보딩 프로세스에 더 큰 유연성을 제공합니다. 서버에 설치된 Istio 사이드카는 기존 평문 트래픽을 중단하지 않고 상호 TLS 트래픽을 즉시 가져옵니다. 결과적으로 운영자는 클라이언트의 Istio 사이드카를 점진적으로 설치하고 구성하여 상호 TLS 트래픽을 전송할 수 있습니다. 클라이언트 구성이 완료되면 운영자는 서버를 상호 TLS 전용 모드로 구성 할 수 있습니다.

### Secure Naming

서버 ID는 인증서로 인코딩되지만 서비스 이름은 검색 서비스 또는 DNS를 통해 검색됩니다. 보안 이름 지정 정보는 서버 ID를 서비스 이름에 매핑합니다. ID A와 서비스 이름 B의 매핑은 "A가 서비스 B를 실행할 권한이 있음"을 의미합니다. 컨트롤 플레인은 apiserver를 감시하고 보안 이름 지정 매핑을 생성 한 다음 PEP에 안전하게 배포합니다. 다음 예에서는 인증에서 보안 이름 지정이 중요한 이유를 설명합니다.

서비스 데이터 저장소를 실행하는 합법적 인 서버가 인프라 팀 ID 만 사용한다고 가정합니다. 악의적 인 사용자는 테스트 팀 ID에 대한 인증서와 키를 가지고 있습니다. 악의적 인 사용자는 클라이언트에서 보낸 데이터를 검사하기 위해 서비스를 가장하려고합니다. 악의적 인 사용자는 테스트 팀 ID에 대한 인증서와 키를 사용하여 위조 된 서버를 배포합니다. 악의적 인 사용자가 DNS 스푸핑, BGP / 경로 하이재킹, ARP 스푸핑 등을 통해 데이터 저장소로 전송 된 트래픽을 성공적으로 하이재킹하고이를 위조 된 서버로 리디렉션했다고 가정합니다.

클라이언트가 데이터 저장소 서비스를 호출하면 서버의 인증서에서 테스트 팀 ID를 추출하고 테스트 팀이 안전한 이름 지정 정보로 데이터 저장소를 실행할 수 있는지 확인합니다. 클라이언트는 테스트 팀이 데이터 저장소 서비스를 실행할 수 없음을 감지하고 인증에 실패합니다.

보안 이름 지정은 HTTPS 트래픽에 대한 일반적인 네트워크 하이재킹으로부터 보호 할 수 있습니다. 또한 일반적인 네트워크 하이재킹으로부터 TCP 트래픽을 보호 할 수 있습니다. 그러나 보안 이름 지정은 DNS 스푸핑으로부터 보호되지 않습니다.이 경우 공격자가 DNS를 가로 채 대상의 IP 주소를 수정하기 때문입니다. 이는 TCP 트래픽에 호스트 이름 정보가 포함되어 있지 않고 라우팅을 위해 IP 주소에만 의존 할 수 있기 때문입니다. 실제로 DNS 도용은 클라이언트 측 Envoy가 트래픽을 수신하기 전에도 발생할 수 있습니다.

### Authentication Architecture

피어 및 요청 인증 정책을 사용하여 Istio 메시에서 요청을 수신하는 워크로드에 대한 인증 요구 사항을 지정할 수 있습니다. 메시 연산자는 .yaml 파일을 사용하여 정책을 지정합니다. 정책은 일단 배포되면 Istio 구성 저장소에 저장됩니다. Istio 컨트롤러는 구성 저장소를 감시합니다.

정책이 변경되면 새 정책은 필요한 인증 메커니즘을 수행하는 방법을 PEP에 알려주는 적절한 구성으로 변환됩니다. 제어 플레인은 공개 키를 가져와 JWT 유효성 검사를 위해 구성에 연결할 수 있습니다. 또는 Istiod는 Istio 시스템이 관리하는 키 및 인증서에 대한 경로를 제공하고 상호 TLS를 위해 이를 애플리케이션 파드에 설치합니다. ID 및 인증서 관리 섹션에서 자세한 정보를 찾을 수 있습니다.

Istio는 대상 엔드 포인트에 비동기 적으로 구성 정보를 보냅니다. 프록시가 구성을 수신하면 새 인증 요구 사항이 해당 파드에 즉시 적용됩니다.

요청을 보내는 클라이언트 서비스는 필요한 인증 메커니즘을 따를 책임이 있습니다. 요청 인증의 경우 애플리케이션은 JWT 자격 증명을 획득하고 요청에 첨부해야합니다. 피어 인증의 경우 Istio는 두 PEP 간의 모든 트래픽을 상호 TLS로 자동 업그레이드합니다. 인증 정책이 상호 TLS 모드를 비활성화하는 경우 Istio는 PEP간에 계속 평문 통신을 사용합니다. 이 동작을 재정의하려면 대상 규칙을 사용하여 상호 TLS 모드를 명시 적으로 비활성화합니다. 상호 TLS 인증 섹션에서 상호 TLS 작동 방식에 대해 자세히 알아볼 수 있습니다.

![Authentication Architecture](../../.gitbook/assets/image%20%2840%29.png)

### Authentication Policies

이 섹션에서는 Istio 인증 정책의 작동 방식에 대한 자세한 내용을 제공합니다. 아키텍처 섹션에서 소개했지만, 인증 정책은 서비스 요청을 수신하는 워크로드에 적용됩니다. 상호 TLS에서 클라이언트 측 인증 규칙을 지정하려면 DestinationRule에서 TLSSettings를 지정해야합니다. TLS 설정 참조 문서에서 자세한 정보를 찾을 수 있습니다.

다른 Istio 구성과 마찬가지로 .yaml 파일에서 인증 정책을 지정할 수 있습니다. kubectl을 사용하여 정책을 배포합니다. 다음 예제 인증 정책은 app : reviews 레이블이있는 워크로드에 대한 전송 인증이 상호 TLS를 사용하도록 지정합니다.

```text
apiVersion: "security.istio.io/v1beta1"
kind: "PeerAuthentication"
metadata:
  name: "example-peer-policy"
  namespace: "foo"
spec:
  selector:
    matchLabels:
      app: reviews
  mtls:
    mode: STRICT
```

### Policy Storage

Istio는 메시 범위 정책을 루트 네임 스페이스에 저장합니다. 이러한 정책에는 메시의 모든 워크로드에 적용되는 empty selector 를 적용합니다. 네임 스페이스 범위가있는 정책은 해당 네임 스페이스에 저장되고, 따라서 네임 스페이스 내의 워크로드에만 적용됩니다. 따라서 관리자는 구성 파일의 selector 필드 설정을 통해 인증 정책이 구성한 조건과 일치하는 워크로드에만 적용하도록 설정 가능합니다.

### Selector Field

피어 및 요청 인증 정책은 선택기 필드를 사용하여 정책이 적용되는 워크로드의 레이블을 지정합니다. 다음 예제는 app : product-page 레이블이있는 워크로드에 적용되는 정책의 selector 필드를 보여줍니다.

```text
selector:
  matchLabels:
    app: product-page
```

selector 필드에 값을 제공하지 않으면 Istio는 정책을 정책의 저장소 범위에있는 모든 워크로드에 일치시킵니다. 따라서 selector 필드는 정책의 범위를 지정하는 도움이 됩니다.

* 메시 전체 정책 : 빈 선택기 필드가 있거나없는 루트 네임 스페이스에 대해 지정된 정책입니다.
* 네임 스페이스 전체 정책 : 빈 선택기 필드가 있거나없는 비 루트 네임 스페이스에 대해 지정된 정책입니다.
* 워크로드 별 정책 : 비어 있지 않은 선택기 필드가있는 일반 네임 스페이스에 정의 된 정책입니다.

피어 및 요청 인증 정책은 선택기 필드에 대해 동일한 계층 구조 원칙을 따르지만 Istio는 약간 다른 방식으로이를 결합하고 적용합니다.

메시 전체 피어 인증 정책은 하나만 있고 네임 스페이스 당 하나의 네임 스페이스 전체 피어 인증 정책 만있을 수 있습니다. 동일한 메시 또는 네임 스페이스에 대해 여러 메시 또는 네임 스페이스 전체 피어 인증 정책을 구성 할 때 Istio는 최신 정책을 무시합니다. 둘 이상의 워크로드 별 피어 인증 정책이 일치하면 Istio는 가장 오래된 것을 선택합니다.

Istio는 다음 순서를 사용하여 각 워크로드에 대해 가장 정확한 매칭 정책을 적용합니다.

1. workload-specific
2. namespace-wide
3. mesh-wide

Istio는 매칭되는 모든 요청 인증 정책을 결합하여 단일 요청에 의한 인증 정책에서 나온 것처럼 작동 할 수 있습니다. 따라서 메시 또는 네임 스페이스에 여러 메시 전체 또는 네임 스페이스 전체에 대한 정책을 적용할 수 있습니다. 그러나 이러한 정책 적용은 추천하지 않습니다.

### Peer Authentication

피어 인증 정책은 Istio가 대상 워크로드에 적용하는 상호 TLS 모드를 지정합니다. 다음 모드가 지원됩니다.

* PERMISSIVE : 워크로드는 상호 TLS 및 일반 텍스트 트래픽을 모두 허용합니다. 이 모드는 사이드카가없는 워크로드가 상호 TLS를 사용할 수없는 마이그레이션 중에 가장 유용합니다. 사이드카 주입으로 워크로드가 마이그레이션되면 모드를 STRICT로 전환해야합니다.
* STRICT : 워크로드는 상호 TLS 트래픽 만 허용합니다.
* 비활성화 : 상호 TLS가 비활성화됩니다. 보안 측면에서 자체 보안 솔루션을 제공하지 않는 한이 모드를 사용해서는 안됩니다.

모드가 설정되지 않으면 상위 범위의 모드가 상속됩니다. 모드가 설정되지 않은 메시 전체 피어 인증 정책은 기본적으로 PERMISSIVE 모드를 사용합니다.

다음 피어 인증 정책에서는 상호 TLS를 사용하기 위해 네임 스페이스 foo의 모든 워크로드가 필요합니다.

```text
apiVersion: "security.istio.io/v1beta1"
kind: "PeerAuthentication"
metadata:
  name: "example-policy"
  namespace: "foo"
spec:
  mtls:
    mode: STRICT
```

워크로드 별 피어 인증 정책을 사용하면 포트마다 서로 다른 상호 TLS 모드를 지정할 수 있습니다. 포트 전체 상호 TLS 구성에 대해 워크로드가 요청한 포트만 사용할 수 있습니다. 다음 예제에서는 app : example-app 워크로드에 대해 포트 80에서 상호 TLS를 비활성화하고 다른 모든 포트에 대해 네임 스페이스 전체 피어 인증 정책의 상호 TLS 설정을 사용합니다.

```text
apiVersion: "security.istio.io/v1beta1"
kind: "PeerAuthentication"
metadata:
  name: "example-workload-policy"
  namespace: "foo"
spec:
  selector:
     matchLabels:
       app: example-app
  portLevelMtls:
    80:
      mode: DISABLE
```

위의 피어 인증 정책은 아래의 서비스 구성이 example-app 워크로드의 요청을 example-service의 포트 80에 바인딩했기 때문에 만 작동합니다.

```text
apiVersion: v1
kind: Service
metadata:
  name: example-service
  namespace: foo
spec:
  ports:
  - name: http
    port: 8000
    protocol: TCP
    targetPort: 80
  selector:
    app: example-app
```

### Request Authentication

요청 인증 정책은 JWT \(JSON Web Token\)의 유효성을 검사하는 데 필요한 값을 지정합니다. 이러한 값에는 다음이 포함됩니다.

요청에서 토큰의 위치 발급자 또는 요청 공개 JSON 웹 키 세트 \(JWKS\) Istio는 요청 인증 정책의 규칙에 대해 제시된 토큰이있는 경우 이를 확인하고 유효하지 않은 토큰이 있는 요청을 거부합니다. 요청에 토큰이 없으면 기본적으로 수락됩니다. 토큰없이 요청을 거부하려면 특정 작업 \(예 : 경로 또는 작업\)에 대한 제한을 지정하는 권한 부여 규칙을 제공합니다.

요청 인증 정책은 각각 고유한 위치를 사용하는 경우 둘 이상의 JWT를 지정할 수 있습니다. 둘 이상의 정책이 워크로드와 일치하면 Istio는 단일 정책으로 지정된 것처럼 모든 규칙을 결합합니다. 이 동작은 다른 공급자의 JWT를 수락하도록 워크로드를 프로그래밍하는 데 유용합니다. 그러나 둘 이상의 유효한 JWT가 있는 요청은 이러한 요청의 출력 주체가 정의되지 않았기 때문에 지원되지 않습니다.

### Principals

피어 인증 정책 및 상호 TLS를 사용하는 경우 Istio는 피어 인증에서 source.principal로 ID를 추출합니다. 마찬가지로 요청 인증 정책을 사용할 때 Istio는 JWT의 ID를 request.auth.principal에 할당합니다. 이러한 주체를 사용하여 권한 부여 정책을 설정하고 원격 분석 출력으로 사용합니다.



